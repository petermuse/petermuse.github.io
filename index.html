<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Peter Muse - Personal Website">
    <meta name="theme-color" content="#000000">
    <meta property="og:title" content="Peter Muse">
    <meta property="og:description" content="Peter Muse - Personal Website">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://www.petermuse.com">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Peter Muse">
    <meta name="twitter:description" content="Peter Muse - Personal Website">
    <link rel="preconnect" href="https://www.googletagmanager.com">
    <link rel="dns-prefetch" href="https://www.googletagmanager.com">
    <link rel="apple-touch-icon" href="data:,">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' fill='%23000'/%3E%3Ctext x='35' y='62' font-family='Arial, sans-serif' font-size='60' font-weight='bold' text-anchor='middle' fill='%231DACD6'%3Ep%3C/text%3E%3Ctext x='65' y='62' font-family='Arial, sans-serif' font-size='60' font-weight='bold' text-anchor='middle' fill='%23FF8833'%3Em%3C/text%3E%3C/svg%3E">
    <title>Peter Muse</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="preload" href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@500&display=swap" as="style">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=EB+Garamond:wght@500&display=swap">
    
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Person",
      "name": "Peter Muse",
      "url": "https://www.petermuse.com",
      "sameAs": ["https://www.linkedin.com/in/peter-muse/"]
    }
    </script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-B3KL6DBEM8"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-B3KL6DBEM8');
    </script>
    
    <style>
        :root {
            --blue: #1DACD6;
            --red: #FF5349;
            --green: #76FF7A;
            --yellow: #FFCF48;
            --purple: #C364C5;
            --orange: #FF8833;
            --mint: #71EEB8;
            --gold: #FCD667;
            --pink: #FF9999;
        }
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: black;
            color: white;
            font-family: 'EB Garamond', serif;
            overflow: hidden;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Head canvas container */
        #head-container {
            width: 100%;
            height: 25vh; /* Allocate top 25% of screen to head */
            position: relative;
            margin-bottom: -1rem;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
        }
        
        .name {
            font-size: 6.5rem;
            font-weight: 500;
            line-height: 0.9;
            margin: 0;
            padding: 0;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            will-change: opacity;
        }
        
        .first-name, .last-name {
            display: flex;
            justify-content: center;
        }
        
        .first-name {
            margin-bottom: 0.2rem;
        }
        
        .letter {
            position: relative;
            animation: letterGlow 2s ease-in-out forwards;
            opacity: 1;
            display: inline-block;
            will-change: text-shadow, filter;
            contain: layout;
        }
        
        .letter-p { margin-right: -0.03rem; color: var(--blue); animation-delay: 0.1s; }
        .letter-e1 { margin-left: -0.07rem; margin-right: -0.06rem; color: var(--red); animation-delay: 0.3s; }
        .letter-t { margin-left: -0.08rem; margin-right: -0.08rem; color: var(--green); animation-delay: 0.5s; }
        .letter-e2 { margin-left: -0.08rem; margin-right: -0.04rem; color: var(--yellow); animation-delay: 0.7s; }
        .letter-r { margin-left: -0.07rem; color: var(--purple); animation-delay: 0.9s; }
        
        .letter-m { margin-right: -0.04rem; color: var(--orange); animation-delay: 1.1s; }
        .letter-u { margin-left: -0.06rem; margin-right: -0.05rem; color: var(--mint); animation-delay: 1.3s; }
        .letter-s { margin-left: -0.07rem; margin-right: -0.06rem; color: var(--gold); animation-delay: 1.5s; }
        .letter-e3 { margin-left: -0.07rem; color: var(--pink); animation-delay: 1.7s; }
        
        @keyframes letterGlow {
            0% { 
                text-shadow: none;
                filter: brightness(1);
            }
            50% { 
                text-shadow: 
                    0 0 1px rgba(255, 255, 255, 0.2),
                    0 0 3px rgba(255, 255, 255, 0.2),
                    0 0 10px rgba(255, 255, 255, 0.1);
                filter: brightness(1.15);
            }
            100% { 
                text-shadow: none;
                filter: brightness(1);
            }
        }
        
        .name-container {
            opacity: 1;
            height: auto;
            width: 100%;
            text-align: center;
        }
        
        .linkedin-container {
            position: static;
            opacity: 0;
            animation: fadeInLinkedIn 1s ease-in-out forwards;
            animation-delay: 1.5s;
            margin-top: 3rem;
            width: 3rem;
            height: 3rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .linkedin-svg {
            width: 3rem;
            height: 3rem;
            fill: #c3d8e8;
            animation: breatheGlow 6s cubic-bezier(0.445, 0.05, 0.55, 0.95) infinite;
            will-change: filter, transform;
            transition: filter 0.3s ease, transform 0.3s ease;
        }
        
        .linkedin-container a:hover .linkedin-svg {
            filter: brightness(1.3) drop-shadow(0 0 8px rgba(195, 216, 232, 0.6));
            transform: scale(1.1);
        }
        
        @keyframes fadeInLinkedIn {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
        
        @keyframes breatheGlow {
            0% { filter: brightness(1) blur(0px); }
            50% { filter: brightness(1.05) blur(0.3px); }
            100% { filter: brightness(1) blur(0px); }
        }
        
        @media (max-width: 768px) {
            .name {
                font-size: 4.5rem;
            }
            
            #head-container {
                height: 25vh;
                margin-bottom: 1rem;
            }
        }
        
        @media (max-width: 480px) {
            .name {
                font-size: 3.5rem;
            }
            .linkedin-container {
                margin-top: 2rem;
            }
            
            #head-container {
                height: 25vh;
            }
        }
        
        @media (max-height: 600px) {
            .name {
                font-size: 4rem;
            }
            .linkedin-container {
                margin-top: 1.5rem;
            }
            
            #head-container {
                height: 25vh;
            }
        }
        
        @media (max-height: 400px) and (orientation: landscape) {
            body {
                flex-direction: row;
                justify-content: space-around;
                padding: 0 5%;
            }
            .main-content {
                width: 50%;
            }
            .name {
                font-size: 3rem;
                line-height: 1;
            }
            .linkedin-container {
                margin-top: 0;
                margin-left: 2rem;
            }
            
            #head-container {
                width: 50%;
                height: 100vh;
            }
        }
        
        @media (prefers-reduced-motion: reduce) {
            .letter {
                animation: none;
                opacity: 1;
            }
            
            .linkedin-container {
                animation: none;
                opacity: 1;
            }
            
            .linkedin-svg {
                animation: none;
            }
        }
    </style>
</head>
<body>
    <!-- Container for the 3D head -->
    <div id="head-container" role="img" aria-label="Interactive 3D wireframe head animation"></div>
    
    <div class="main-content">
        <header class="name-container" role="banner">
            <h1 class="name" aria-label="Peter Muse">
                <div class="first-name">
                    <span class="letter letter-p">P</span>
                    <span class="letter letter-e1">e</span>
                    <span class="letter letter-t">t</span>
                    <span class="letter letter-e2">e</span>
                    <span class="letter letter-r">r</span>
                </div>
                <div class="last-name">
                    <span class="letter letter-m">M</span>
                    <span class="letter letter-u">u</span>
                    <span class="letter letter-s">s</span>
                    <span class="letter letter-e3">e</span>
                </div>
            </h1>
        </header>
        
        <footer class="linkedin-container" role="contentinfo">
            <a href="https://www.linkedin.com/in/peter-muse/" target="_self" rel="noopener noreferrer" aria-label="Connect with Peter Muse on LinkedIn">
                <svg class="linkedin-svg" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                    <title>LinkedIn Profile</title>
                    <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.454C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.225 0z"/>
                </svg>
            </a>
        </footer>
    </div>
    
    <!-- Import Three.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Script for the 3D wireframe head -->
    <script>
        // Wait for the DOM to be fully loaded
        window.addEventListener('DOMContentLoaded', function() {
            // Initialize Three.js only after the library is fully loaded
            setTimeout(initThreeJS, 100);
        });

        function initThreeJS() {
            try {
                // Check if Three.js is available
                if (typeof THREE === 'undefined') {
                    console.error('Three.js library not loaded');
                    return;
                }

                // Scene, camera, renderer setup
                const scene = new THREE.Scene();
                const container = document.getElementById('head-container');
                const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
                camera.position.z = 5;

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setClearColor(0x000000, 1);
                container.appendChild(renderer.domElement);

                // Materials
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: 0x00ff00,
                    transparent: true,
                    opacity: 0.8
                });

                // Animation states
                const STATE = {
                    SLEEPING: 'sleeping',
                    WHISTLING: 'whistling',
                    NORMAL: 'normal' // Not used but kept for potential future use
                };
                
                // Current state tracking
                let currentState = null;
                let lastStateChange = Date.now();
                
                // Mouse tracking (only used when not in sleeping hours)
                let mouseX = 0;
                let mouseY = 0;
                let targetRotationX = 0;
                let targetRotationY = 0;
                const windowHalfX = container.clientWidth / 2;
                const windowHalfY = container.clientHeight / 2;

                // Create head group
                const head = new THREE.Group();
                scene.add(head);
                
                // Create face components
                const eyesGroup = new THREE.Group();
                head.add(eyesGroup);

                // Different eye states
                const leftEyeOpen = createEye(-0.45, 'open');
                const rightEyeOpen = createEye(0.45, 'open');
                eyesGroup.add(leftEyeOpen);
                eyesGroup.add(rightEyeOpen);
                
                const leftEyeClosed = createEye(-0.45, 'closed');
                const rightEyeClosed = createEye(0.45, 'closed');
                leftEyeClosed.visible = false;
                rightEyeClosed.visible = false;
                eyesGroup.add(leftEyeClosed);
                eyesGroup.add(rightEyeClosed);
                
                // Different mouth states
                const normalMouth = createMouth('normal');
                const whistlingMouth = createMouth('whistling');
                head.add(normalMouth);
                head.add(whistlingMouth);
                whistlingMouth.visible = false;
                
                // Create animation elements
                const zzzGroup = createZzzGroup();
                zzzGroup.visible = false;
                scene.add(zzzGroup);
                
                const musicNotesGroup = createMusicNotesGroup();
                musicNotesGroup.visible = false;
                scene.add(musicNotesGroup);
                
                // Create face outline and other facial features
                head.add(createFaceOutline());
                head.add(createNose());
                head.add(createJawline());
                head.add(createProfileLines());
                
                // Event listeners (only active during day hours)
                container.addEventListener('mousemove', function(event) {
                    // Get mouse position relative to the container
                    const rect = container.getBoundingClientRect();
                    const x = event.clientX - rect.left;
                    const y = event.clientY - rect.top;
                    
                    // Only respond to mouse if not in sleep time
                    if (!isCaliforniaSleepTime()) {
                        mouseX = (x - windowHalfX) / 50;
                        mouseY = (y - windowHalfY) / 50;
                    }
                });
                
                window.addEventListener('resize', onWindowResize);
                
                // Initial state setup based on time
                updateStateBasedOnTime();
                
                // Start animation loop
                animate();
                
                // Set up periodic time check (every minute)
                setInterval(updateStateBasedOnTime, 60000);
                
                // Time checking functions
                function isCaliforniaSleepTime() {
                    const now = new Date();
                    
                    // Convert to California time (PT)
                    const californiaNow = new Date(now.toLocaleString("en-US", {timeZone: "America/Los_Angeles"}));
                    const hours = californiaNow.getHours();
                    
                    // Sleep time is 10pm (22) to 6am (6)
                    return hours >= 22 || hours < 6;
                }
                
                function updateStateBasedOnTime() {
                    const sleepTime = isCaliforniaSleepTime();
                    
                    if (sleepTime && currentState !== STATE.SLEEPING) {
                        // Switch to sleeping state
                        switchToState(STATE.SLEEPING);
                    } else if (!sleepTime && currentState !== STATE.WHISTLING) {
                        // Switch to whistling state
                        switchToState(STATE.WHISTLING);
                    }
                }
                
                function switchToState(newState) {
                    // Reset animation timers
                    lastStateChange = Date.now();
                    
                    // Update current state
                    currentState = newState;
                    
                    if (newState === STATE.SLEEPING) {
                        // Sleeping state setup
                        leftEyeOpen.visible = false;
                        rightEyeOpen.visible = false;
                        leftEyeClosed.visible = true;
                        rightEyeClosed.visible = true;
                        
                        normalMouth.visible = true;
                        whistlingMouth.visible = false;
                        
                        zzzGroup.visible = true;
                        musicNotesGroup.visible = false;
                        
                        // Reset Z positions
                        zzzGroup.children.forEach((z, i) => {
                            z.position.y = 1.6 + (i * 0.2);
                            z.position.x = 0.1 + (i * 0.2);
                        });
                        
                    } else if (newState === STATE.WHISTLING) {
                        // Whistling state setup
                        leftEyeOpen.visible = true;
                        rightEyeOpen.visible = true;
                        leftEyeClosed.visible = false;
                        rightEyeClosed.visible = false;
                        
                        normalMouth.visible = false;
                        whistlingMouth.visible = true;
                        
                        zzzGroup.visible = false;
                        musicNotesGroup.visible = true;
                        
                        // Reset music note positions
                        musicNotesGroup.children.forEach((note, i) => {
                            note.position.y = 1.5 + (i * 0.2);
                            note.position.x = 0.1 + (i * 0.15);
                        });
                    }
                }
                
                // Function to create eye (different states)
                function createEye(xOffset, state) {
                    const eye = new THREE.Group();
                    eye.position.z = 1;
                    
                    let points = [];
                    if (state === 'open') {
                        // Diamond shape for open eye
                        points = [
                            new THREE.Vector3(xOffset - 0.2, 0.3, 0),
                            new THREE.Vector3(xOffset, 0.4, 0),
                            new THREE.Vector3(xOffset + 0.2, 0.3, 0),
                            new THREE.Vector3(xOffset, 0.2, 0),
                            new THREE.Vector3(xOffset - 0.2, 0.3, 0)
                        ];
                    } else if (state === 'closed') {
                        // Horizontal line for closed eye
                        points = [
                            new THREE.Vector3(xOffset - 0.2, 0.3, 0),
                            new THREE.Vector3(xOffset + 0.2, 0.3, 0)
                        ];
                    }
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    eye.add(line);
                    
                    return eye;
                }
                
                // Function to create different mouth states
                function createMouth(type) {
                    const mouth = new THREE.Group();
                    mouth.position.z = 1;
                    
                    let points = [];
                    if (type === 'normal') {
                        // Slight smile
                        points = [
                            new THREE.Vector3(-0.25, -0.5, 0),
                            new THREE.Vector3(0, -0.55, 0),
                            new THREE.Vector3(0.25, -0.5, 0)
                        ];
                    } else if (type === 'whistling') {
                        // Small "o" shape for whistling
                        const segments = 8;
                        const radius = 0.1;
                        
                        for (let i = 0; i <= segments; i++) {
                            const theta = (i / segments) * Math.PI * 2;
                            points.push(new THREE.Vector3(
                                Math.cos(theta) * radius,
                                Math.sin(theta) * radius - 0.5,
                                0
                            ));
                        }
                    }
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    mouth.add(line);
                    
                    return mouth;
                }
                
                // Function to create face outline
                function createFaceOutline() {
                    const points = [
                        new THREE.Vector3(0, 1.4, 0),
                        new THREE.Vector3(0.7, 1.2, 0),
                        new THREE.Vector3(0.9, 0.8, 0),
                        new THREE.Vector3(1.0, 0.4, 0),
                        new THREE.Vector3(1.0, 0, 0),
                        new THREE.Vector3(0.95, -0.3, 0),
                        new THREE.Vector3(0.85, -0.5, 0),
                        new THREE.Vector3(0, -0.7, 0),
                        new THREE.Vector3(-0.85, -0.5, 0),
                        new THREE.Vector3(-0.95, -0.3, 0),
                        new THREE.Vector3(-1.0, 0, 0),
                        new THREE.Vector3(-1.0, 0.4, 0),
                        new THREE.Vector3(-0.9, 0.8, 0),
                        new THREE.Vector3(-0.7, 1.2, 0),
                        new THREE.Vector3(0, 1.4, 0)
                    ];
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    line.position.z = 0.6;
                    
                    return line;
                }
                
                // Function to create nose
                function createNose() {
                    const points = [
                        new THREE.Vector3(0, 0.1, 0),
                        new THREE.Vector3(0, -0.15, 0),
                        new THREE.Vector3(0.15, -0.1, 0)
                    ];
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    line.position.z = 1.2;
                    
                    return line;
                }
                
                // Function to create jawline
                function createJawline() {
                    const points = [
                        new THREE.Vector3(-0.7, -0.4, 0),
                        new THREE.Vector3(-0.5, -0.5, 0),
                        new THREE.Vector3(-0.25, -0.6, 0),
                        new THREE.Vector3(0, -0.65, 0),
                        new THREE.Vector3(0.25, -0.6, 0),
                        new THREE.Vector3(0.5, -0.5, 0),
                        new THREE.Vector3(0.7, -0.4, 0)
                    ];
                    
                    const geometry = new THREE.BufferGeometry().setFromPoints(points);
                    const line = new THREE.Line(geometry, lineMaterial);
                    line.position.z = 0.8;
                    
                    return line;
                }
                
                // Function to create profile lines
                function createProfileLines() {
                    const group = new THREE.Group();
                    
                    // Center line
                    const centerPoints = [
                        new THREE.Vector3(0, 1.3, 0.6),
                        new THREE.Vector3(0, -0.7, 0.6)
                    ];
                    
                    const centerGeometry = new THREE.BufferGeometry().setFromPoints(centerPoints);
                    const centerLine = new THREE.Line(centerGeometry, lineMaterial);
                    group.add(centerLine);
                    
                    // Contour line 1
                    const contour1Points = [
                        new THREE.Vector3(0.6, 0.4, 0.6),
                        new THREE.Vector3(0.4, 0.4, 1.0),
                        new THREE.Vector3(0, 0.4, 1.2),
                        new THREE.Vector3(-0.4, 0.4, 1.0),
                        new THREE.Vector3(-0.6, 0.4, 0.6)
                    ];
                    
                    const contour1Geometry = new THREE.BufferGeometry().setFromPoints(contour1Points);
                    const contour1Line = new THREE.Line(contour1Geometry, lineMaterial);
                    group.add(contour1Line);
                    
                    // Contour line 2
                    const contour2Points = [
                        new THREE.Vector3(0.5, -0.1, 0.6),
                        new THREE.Vector3(0.3, -0.1, 1.0),
                        new THREE.Vector3(0, -0.1, 1.2),
                        new THREE.Vector3(-0.3, -0.1, 1.0),
                        new THREE.Vector3(-0.5, -0.1, 0.6)
                    ];
                    
                    const contour2Geometry = new THREE.BufferGeometry().setFromPoints(contour2Points);
                    const contour2Line = new THREE.Line(contour2Geometry, lineMaterial);
                    group.add(contour2Line);
                    
                    return group;
                }
                
                // Function to create ZZZ group for sleeping animation
                function createZzzGroup() {
                    const group = new THREE.Group();
                    
                    // Z character 1 (smallest)
                    const z1 = createZCharacter(0.2);
                    z1.position.set(0.1, 1.6, 0);
                    group.add(z1);
                    
                    // Z character 2 (medium)
                    const z2 = createZCharacter(0.3);
                    z2.position.set(0.3, 1.8, 0);
                    group.add(z2);
                    
                    // Z character 3 (largest)
                    const z3 = createZCharacter(0.4);
                    z3.position.set(0.5, 2.0, 0);
                    group.add(z3);
                    
                    return group;
                }
                
                // Function to create a Z character
                function createZCharacter(size) {
                    const group = new THREE.Group();
                    
                    // Top line
                    const topPoints = [
                        new THREE.Vector3(-size/2, size/2, 0),
                        new THREE.Vector3(size/2, size/2, 0)
                    ];
                    
                    const topGeometry = new THREE.BufferGeometry().setFromPoints(topPoints);
                    const topLine = new THREE.Line(topGeometry, lineMaterial);
                    group.add(topLine);
                    
                    // Diagonal line
                    const diagPoints = [
                        new THREE.Vector3(size/2, size/2, 0),
                        new THREE.Vector3(-size/2, -size/2, 0)
                    ];
                    
                    const diagGeometry = new THREE.BufferGeometry().setFromPoints(diagPoints);
                    const diagLine = new THREE.Line(diagGeometry, lineMaterial);
                    group.add(diagLine);
                    
                    // Bottom line
                    const bottomPoints = [
                        new THREE.Vector3(-size/2, -size/2, 0),
                        new THREE.Vector3(size/2, -size/2, 0)
                    ];
                    
                    const bottomGeometry = new THREE.BufferGeometry().setFromPoints(bottomPoints);
                    const bottomLine = new THREE.Line(bottomGeometry, lineMaterial);
                    group.add(bottomLine);
                    
                    return group;
                }
                
                // Function to create music notes group for whistling animation
                function createMusicNotesGroup() {
                    const group = new THREE.Group();
                    
                    // Create different music note shapes
                    const note1 = createEighthNote(0.15);
                    note1.position.set(0.1, 1.5, 0);
                    group.add(note1);
                    
                    const note2 = createQuarterNote(0.2);
                    note2.position.set(0.25, 1.7, 0);
                    group.add(note2);
                    
                    const note3 = createEighthNote(0.25);
                    note3.position.set(0.4, 1.9, 0);
                    group.add(note3);
                    
                    return group;
                }
                
                // Function to create an eighth note
                function createEighthNote(size) {
                    const group = new THREE.Group();
                    
                    // Note head (oval)
                    const headSegments = 8;
                    const headPoints = [];
                    
                    for (let i = 0; i <= headSegments; i++) {
                        const theta = (i / headSegments) * Math.PI * 2;
                        headPoints.push(new THREE.Vector3(
                            Math.cos(theta) * size * 0.4,
                            Math.sin(theta) * size * 0.6,
                            0
                        ));
                    }
                    
                    const headGeometry = new THREE.BufferGeometry().setFromPoints(headPoints);
                    const head = new THREE.Line(headGeometry, lineMaterial);
                    head.rotation.z = Math.PI / 4; // Tilt the note head
                    group.add(head);
                    
                    // Note stem
                    const stemPoints = [
                        new THREE.Vector3(size * 0.25, size * 0.25, 0),
                        new THREE.Vector3(size * 0.25, size * 1.5, 0)
                    ];
                    
                    const stemGeometry = new THREE.BufferGeometry().setFromPoints(stemPoints);
                    const stem = new THREE.Line(stemGeometry, lineMaterial);
                    group.add(stem);
                    
                    // Note flag
                    const flagPoints = [
                        new THREE.Vector3(size * 0.25, size * 1.5, 0),
                        new THREE.Vector3(size * 0.8, size * 1.2, 0)
                    ];
                    
                    const flagGeometry = new THREE.BufferGeometry().setFromPoints(flagPoints);
                    const flag = new THREE.Line(flagGeometry, lineMaterial);
                    group.add(flag);
                    
                    return group;
                }
                
                // Function to create a quarter note
                function createQuarterNote(size) {
                    const group = new THREE.Group();
                    
                    // Note head (oval)
                    const headSegments = 8;
                    const headPoints = [];
                    
                    for (let i = 0; i <= headSegments; i++) {
                        const theta = (i / headSegments) * Math.PI * 2;
                        headPoints.push(new THREE.Vector3(
                            Math.cos(theta) * size * 0.4,
                            Math.sin(theta) * size * 0.6,
                            0
                        ));
                    }
                    
                    const headGeometry = new THREE.BufferGeometry().setFromPoints(headPoints);
                    const head = new THREE.Line(headGeometry, lineMaterial);
                    head.rotation.z = Math.PI / 4; // Tilt the note head
                    group.add(head);
                    
                    // Note stem
                    const stemPoints = [
                        new THREE.Vector3(size * 0.25, size * 0.25, 0),
                        new THREE.Vector3(size * 0.25, size * 1.5, 0)
                    ];
                    
                    const stemGeometry = new THREE.BufferGeometry().setFromPoints(stemPoints);
                    const stem = new THREE.Line(stemGeometry, lineMaterial);
                    group.add(stem);
                    
                    return group;
                }
                
                // Window resize event handler
                function onWindowResize() {
                    camera.aspect = container.clientWidth / container.clientHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(container.clientWidth, container.clientHeight);
                    
                    // Update mouse tracking references
                    windowHalfX = container.clientWidth / 2;
                    windowHalfY = container.clientHeight / 2;
                }
                
                // Animation loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    // Animation based on current state
                    if (currentState === STATE.SLEEPING) {
                        // Animate ZZZs floating up
                        zzzGroup.children.forEach(z => {
                            z.position.y += 0.003;
                            
                            // If Z goes too high, reset it to start position
                            if (z.position.y > 2.5) {
                                z.position.y = 1.5; 
                            }
                        });
                        
                        // Keep head in neutral position during sleep
                        head.rotation.y = 0;
                        head.rotation.x = 0;
                        
                    } else if (currentState === STATE.WHISTLING) {
                        // Animate music notes floating up and to the side
                        musicNotesGroup.children.forEach(note => {
                            note.position.y += 0.004;
                            note.position.x += 0.001;
                            
                            // If note goes too high, reset it
                            if (note.position.y > 2.5) {
                                note.position.y = 1.5;
                                note.position.x = 0.1 + Math.random() * 0.2;
                            }
                        });
                        
                        // Add impatient head movements
                        const time = Date.now() * 0.001;
                        head.rotation.y = Math.sin(time * 0.5) * 0.1;
                        
                        // Add mouse tracking during day
                        targetRotationY = mouseX * 0.03;
                        targetRotationX = mouseY * 0.03;
                        
                        head.rotation.y += (targetRotationY - head.rotation.y) * 0.05;
                        head.rotation.x += (targetRotationX - head.rotation.x) * 0.05;
                    }
                    
                    // Subtle pulsing effect
                    const time = Date.now() * 0.001;
                    lineMaterial.opacity = 0.7 + Math.sin(time) * 0.1;
                    
                    // Render the scene
                    renderer.render(scene, camera);
                }
            } catch (error) {
                console.error('Error initializing 3D head:', error);
                document.getElementById('head-container').innerHTML = '<div style="color: #0f0; font-family: monospace; margin: 20px; text-align: center;">' + 
                                    'Error initializing 3D head: ' + error.message + '<br><br>Please reload the page to try again.</div>';
            }
        }
    </script>
</body>
</html>